const testPy = "from ast import parse, NodeVisitor, Name\r\n_NAMES = {\r\n    \'Add\': \'+\',\r\n    \'And\': \'and\',\r\n    \'Assert\': \'assert\',\r\n    \'Assign\': \'=\',\r\n    \'AugAssign\': \'op=\',\r\n    \'BitAnd\': \'&\',\r\n    \'BitOr\': \'|\',\r\n    \'BitXor\': \'^\',\r\n    \'Break\': \'break\',\r\n    \'Recursion\': \'recursive call\',\r\n    \'ClassDef\': \'class\',\r\n    \'Continue\': \'continue\',\r\n    \'Del\': \'del\',\r\n    \'Delete\': \'delete\',\r\n    \'Dict\': \'{...}\',\r\n    \'DictComp\': \'{...}\',\r\n    \'Div\': \'\/\',\r\n    \'Ellipsis\': \'...\',\r\n    \'Eq\': \'==\',\r\n    \'ExceptHandler\': \'except\',\r\n    \'ExtSlice\': \'[::]\',\r\n    \'FloorDiv\': \'\/\/\',\r\n    \'For\': \'for\',\r\n    \'FunctionDef\': \'def\',\r\n    \'GeneratorExp\': \'(... for ...)\',\r\n    \'Global\': \'global\',\r\n    \'Gt\': \'>\',\r\n    \'GtE\': \'>=\',\r\n    \'If\': \'if\',\r\n    \'IfExp\': \'...if...else...\',\r\n    \'Import\': \'import\',\r\n    \'ImportFrom\': \'from ... import ...\',\r\n    \'In\': \'in\',\r\n    \'Index\': \'...[...]\',\r\n    \'Invert\': \'~\',\r\n    \'Is\': \'is\',\r\n    \'IsNot\': \'is not \',\r\n    \'LShift\': \'<<\',\r\n    \'Lambda\': \'lambda\',\r\n    \'List\': \'[...]\',\r\n    \'ListComp\': \'[...for...]\',\r\n    \'Lt\': \'<\',\r\n    \'LtE\': \'<=\',\r\n    \'Mod\': \'%\',\r\n    \'Mult\': \'*\',\r\n    \'Nonlocal\': \'nonlocal\',\r\n    \'Not\': \'not\',\r\n    \'NotEq\': \'!=\',\r\n    \'NotIn\': \'not in\',\r\n    \'Or\': \'or\',\r\n    \'Pass\': \'pass\',\r\n    \'Pow\': \'**\',\r\n    \'RShift\': \'>>\',\r\n    \'Raise\': \'raise\',\r\n    \'Return\': \'return\',\r\n    \'Set\': \'{ ... } (set)\',\r\n    \'SetComp\': \'{ ... for ... } (set)\',\r\n    \'Slice\': \'[ : ]\',\r\n    \'Starred\': \'\',\r\n    \'Sub\': \'-\',\r\n    \'Subscript\': \'[]\',\r\n    \'Try\': \'try\',\r\n    \'Tuple\': \'(... , ... )\',\r\n    \'UAdd\': \'+\',\r\n    \'USub\': \'-\',\r\n    \'While\': \'while\',\r\n    \'With\': \'with\',\r\n    \'Yield\': \'yield\',\r\n    \'YieldFrom\': \'yield from\',\r\n}\r\ndef check(source_file, checked_funcs, disallow, source=None):\r\n    \"\"\"Checks that AST nodes whose type names are present in DISALLOW\r\n    (an object supporting \'in\') are not present in the function(s) named\r\n    CHECKED_FUNCS in SOURCE.  By default, SOURCE is the contents of the\r\n    file SOURCE_FILE.  CHECKED_FUNCS is either a string (indicating a single\r\n    name) or an object of some other type that supports \'in\'. CHECKED_FUNCS\r\n    may contain __main__ to indicate an entire  module. Prints reports of\r\n    each prohibited node and returns True iff none are found.\r\n    See ast.__dir__() for AST type names.  The special node name \'Recursion\'\r\n    checks for overtly recursive calls (i.e., calls of the form NAME(...) where\r\n    NAME is an enclosing def.\"\"\"\r\n    return ExclusionChecker(disallow).check(source_file, checked_funcs, source)\r\nclass ExclusionChecker(NodeVisitor):\r\n    \"\"\"An AST visitor that checks that certain constructs are excluded from\r\n    parts of a program.  ExclusionChecker(EXC) checks that AST node types\r\n    whose names are in the sequence or set EXC are not present.  Its check\r\n    method visits nodes in a given function of a source file checking that the\r\n    indicated node types are not used.\"\"\"\r\n\r\n    def __init__(self, disallow=()):\r\n        \"\"\"DISALLOW is the initial default list of disallowed\r\n        node-type names.\"\"\"\r\n        self._disallow = set(disallow)\r\n        self._checking = False\r\n        self._errs = 0\r\n\r\n    def generic_visit(self, node):\r\n        if self._checking and type(node).__name__ in self._disallow:\r\n            self._report(node)\r\n        super().generic_visit(node)\r\n\r\n    def visit_Module(self, node):\r\n        if \"__main__\" in self._checked_funcs:\r\n            self._checking = True\r\n            self._checked_name = self._source_file\r\n        super().generic_visit(node)\r\n\r\n    def visit_Call(self, node):\r\n        if \'Recursion\' in self._disallow and \\\r\n           type(node.func) is Name and \\\r\n           node.func.id in self._func_nest:\r\n            self._report(node, \"should not be recursive\")\r\n        self.generic_visit(node)\r\n\r\n    def visit_FunctionDef(self, node):\r\n        self._func_nest.append(node.name)\r\n        if self._checking:\r\n            self.generic_visit(node)\r\n        elif node.name in self._checked_funcs:\r\n            self._checked_name = \"Function \" + node.name\r\n            checking0 = self._checking\r\n            self._checking = True\r\n            super().generic_visit(node)\r\n            self._checking = checking0\r\n        self._func_nest.pop()\r\n\r\n    def _report(self, node, msg=None):\r\n        node_name = _NAMES.get(type(node).__name__, type(node).__name__)\r\n        if msg is None:\r\n            msg = \"should not contain \'{}\'\".format(node_name)\r\n        print(\"{} {}\".format(self._checked_name, msg))\r\n        self._errs += 1\r\n\r\n    def errors(self):\r\n        \"\"\"Returns the number of number of prohibited constructs found in\r\n        the last call to check.\"\"\"\r\n        return self._errs\r\n\r\n    def check(self, source_file, checked_funcs, disallow=None, source=None):\r\n        \"\"\"Checks that AST nodes whose type names are present in DISALLOW\r\n        (an object supporting the contains test) are not present in\r\n        the function(s) named CHECKED_FUNCS in SOURCE.  By default, SOURCE\r\n        is the contents of the file SOURCE_FILE.  DISALLOW defaults to the\r\n        argument given to the constructor (and resets that value if it is\r\n        present).  CHECKED_FUNCS is either a string (indicating a single\r\n        name) or an object of some other type that supports \'in\'.\r\n        CHECKED_FUNCS may contain __main__ to indicate an entire module.\r\n        Prints reports of each prohibited node and returns True iff none\r\n        are found.\r\n        See ast.__dir__() for AST type names.  The special node name\r\n        \'Recursion\' checks for overtly recursive calls (i.e., calls of the\r\n        form NAME(...) where NAME is an enclosing def.\"\"\"\r\n\r\n        self._checking = False\r\n        self._source_file = source_file\r\n        self._func_nest = []\r\n        if type(checked_funcs) is str:\r\n            self._checked_funcs = { checked_funcs }\r\n        else:\r\n            self._checked_funcs = set(checked_funcs)\r\n        if disallow is not None:\r\n            self._disallow = set(disallow)\r\n        if source is None:\r\n            with open(source_file, \'r\', errors=\'ignore\') as inp:\r\n                source = inp.read()\r\n        p = parse(source, source_file)\r\n        self._errs = 0\r\n\r\n        self.visit(p)\r\n        return self._errs == 0\r\n\r\n\r\nfrom homework import *\r\nimport sys\r\nprint(\"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\")\r\nclass Test:\r\n    def assertEqual(self, a, b):\r\n        return a==b\r\n\r\n    def __init__(self, question):\r\n        self.question = question\r\n        self.tests_passed = 0\r\n\r\n    def test(self):\r\n        print(\"---------------------------------------------------------------------\\n\")\r\n        print(\"Testing {}:\\n\".format(self.question[\'functionName\'] if self.question[\'advancedSetting\'][\'testName\'].strip() == \"\" else self.question[\'advancedSetting\'][\'testName\']))\r\n\r\n        for testCase in self.question[\'testCases\']:\r\n            if not self.test_one_pair(testCase):\r\n                print(\"{} test(s) passed before encountering the first failed case.\".format(self.tests_passed))\r\n                print(\"\\n---------------------------------------------------------------------\")\r\n                return (False, 0)\r\n\r\n        disallowedUse = eval(\"(\" + self.question[\'advancedSetting\'][\'disallowedUse\'] + \")\")\r\n        if disallowedUse:\r\n            if (not check(\"homework.py\", self.question[\'functionName\'], disallowedUse)):\r\n                print(\"Please revise your code and remove these usages.\")\r\n                print(\"\\n---------------------------------------------------------------------\")\r\n                return (False, 0)\r\n        print(\"All {} cases passed. No cases failed.\".format(len(self.question[\'testCases\'])))\r\n        print(\"\\n---------------------------------------------------------------------\")\r\n        return (True, int(self.question[\"advancedSetting\"][\"fullScore\"]))\r\n\r\n    def test_one_pair(self, testCase):\r\n        try:\r\n            expected = eval(testCase[1])\r\n        except:\r\n            print(\"It\'s not you, it\'s the teacher! \\n\" +\r\n                \"There\'s an error in the test case: cannot evaluate \'\" + testCase[1] + \"\'\\n\" +\r\n                \"Please contact your teacher. \\n(Don\'t laugh at them too hard though, sh!t happens :))\\n\")\r\n            return False\r\n        funcCallRepr = self.question[\"functionName\"] + \"(\" + testCase[0] + \")\"\r\n        try:\r\n            answer = eval(self.question[\"functionName\"] + \"(\" + testCase[0] + \")\")\r\n        except Exception as ex:\r\n            print(\"Running {}:\\n\".format(funcCallRepr))\r\n            message = \"{} occurred while executing your function. Current test terminated.\\n\".format(type(ex).__name__)\r\n            print(message)\r\n            return False\r\n\r\n        if self.assertEqual(answer, expected):\r\n            self.tests_passed += 1\r\n            return True\r\n        else:\r\n            print(\"Running {}:\".format(funcCallRepr))\r\n            print(\"Expected: {}\\nGot: {}\\n\".format(expected, answer))\r\n            return False\r\n\r\n# questionNames = [ question[\'functionName\'] if question[\'advancedSetting\'][\'testName\'].strip() == \"\" else question[\'advancedSetting\'][\'testName\'] for question in d[\"tests\"]]\r\nquestionD = {question[\'functionName\']\r\n    if question[\'advancedSetting\'][\'testName\'].strip() == \"\"\r\n    else question[\'advancedSetting\'][\'testName\']\r\n    :\r\n    Test(question)\r\n    for question in d[\"tests\"]\r\n    }\r\nif len(sys.argv) > 1:\r\n    assert sys.argv[1] in questionD, \"\\nThe command line argument you passed in is not a valid function name; choose from {}\\n\".format(list(questionD.keys()).__repr__())\r\n    questionD[sys.argv[1]].test()\r\nelif d[\"pointsEnabled\"]:\r\n    print(\"Total score: \" + str(sum([t.test()[1] for t in questionD.values()])))\r\nprint(\"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\")\r\n";
function generateTest(FORM_STATE) {
  return "d = eval(\"" +
    JSON.stringify(FORM_STATE).replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/"/g, '\\"') +
    "\".replace(\"true\", \"True\"))\n" + testPy;
}

export {generateTest};
