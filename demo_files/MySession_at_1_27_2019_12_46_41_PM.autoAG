{"pointsEnabled":true,"starterCode":"# Tree ADT\ndef tree(label, branches=[]):\n    \"\"\"Construct a tree with the given label value and a list of branches.\"\"\"\n    for branch in branches:\n        assert is_tree(branch), 'branches must be trees'\n    return [label] + list(branches)\n\ndef label(tree):\n    \"\"\"Return the label value of a tree.\"\"\"\n    return tree[0]\n\ndef branches(tree):\n    \"\"\"Return the list of branches of the given tree.\"\"\"\n    return tree[1:]\n\ndef is_tree(tree):\n    \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\"\n    if type(tree) != list or len(tree) < 1:\n        return False\n    for branch in branches(tree):\n        if not is_tree(branch):\n            return False\n    return True\n\ndef is_leaf(tree):\n    \"\"\"Returns True if the given tree's list of branches is empty, and False\n    otherwise.\n    \"\"\"\n    return not branches(tree)\n","tests":[{"functionName":"twenty_nineteen","functionParams":"","description":"Come up with the most creative way of returning 2019.","testCases":[["","2019"]],"advancedSetting":{"fullScore":"1","testType":"simple","testName":"","partialCredits":"none","skeletonCode":"return ________ #FIXME","disallowedUse":""}},{"functionName":"factorial_iter","functionParams":"n","description":"Return the factorial of `n`. Please \nuse an iterative solution; do not\nuse recursion.","testCases":[["0","1"],["1","1"],["3","6"],["4","24"],["10","3628800"]],"advancedSetting":{"fullScore":"1","testType":"simple","testName":"","partialCredits":"none","skeletonCode":"'*** YOUR CODE HERE ***'","disallowedUse":"\"Recursion\""}},{"functionName":"factorial_recur","functionParams":"n","description":"Return the factorial of `n`. Please \nuse an recursive solution; do not use \nany forms of loops.","testCases":[["0","1"],["1","1"],["3","6"],["4","24"],["10","3628800"]],"advancedSetting":{"fullScore":"1","testType":"simple","testName":"","partialCredits":"none","skeletonCode":"'*** YOUR CODE HERE ***'","disallowedUse":"\"For\", \"While\""}},{"functionName":"acorn_finder","functionParams":"t","description":"Returns True if `t` contains a node with the \nvalue 'acorn' and False otherwise. Example from CS61A lab.","testCases":[["tree('roots', [tree('branch1', [tree('leaf'), tree('acorn')]), tree('branch2')])","True"],["tree('acorn')","True"],["tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])","False"]],"advancedSetting":{"fullScore":"1","testType":"simple","testName":"","partialCredits":"none","skeletonCode":"'*** YOUR CODE HERE ***'","disallowedUse":""}},{"functionName":"remove_from_list_wrapper","functionParams":"inputs, expected","description":"AutoAG was designed to generate simple questions: \nwe usually ask students to write pure functions and \ntest them based solely on their outputs. However, if \nyou do want to write unit-test-ish questions, here's \nan example of the workaround.","testCases":[["([1, 2, 3], 1), [1, 3]","True"],["([1, 2, 3, 5], 0), [2, 3, 5]","True"]],"advancedSetting":{"fullScore":"1","testType":"simple","testName":"","partialCredits":"none","skeletonCode":"def remove_from_list(lst, i):\n    '''Modify the original list `lst`: \n    remove the `i`th element in the list.\n    '''\n    '### YOUR CODE HERE ###'\n\nremove_from_list(*inputs)\nreturn inputs[0] == expected","disallowedUse":""}}]}